import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm


def generate_noise(signal, R, EbN0):
    """Generate the noise array for a given signal and its SNR

    The array of randomly generated values is multiplied with the
    noise variance which is computed using the SNR value. The array
    thus obtained is the noise array.

    Args:
        signal (array): signal array
        R (int): symbol rate
        EbN0 (float): SNR value

    Returns:
        noise (array): The noise array
    """
    ns = len(signal)
    noise = (1 / np.sqrt(2 * R * EbN0)) * (
        np.random.normal(size=ns) + np.random.normal(size=ns) * 1j
    )
    return noise


def generate_BPSK_SER_vs_EbN0_Pr(EbN0dB_range):
    """Generate practical SER for a BPSK signal

    The randomly generated message is converted to its corresponding
    BPSK signal by changing all the 0s to -1. The resulting signal
    array denotes the phase shift property. Noise is added to the
    signal and then the receiver decodes the signal by just checking
    the sign to obtain the received message array.

    Args:
        EbN0dB_range (range): range object containing the range of SNR
                              values used in simulations

    Returns:
        SER (list): list of SER values as computed during the simulations
    """
    msg = np.random.randint(low=0, high=2, size=int(1e6))
    signal = np.ones(len(msg))
    for i, j in enumerate(msg):
        if j == 0:
            signal[i] = -1

    SER = []
    for EbN0dB in EbN0dB_range:
        EbN0 = 10 ** (EbN0dB / 10.0)
        noise = generate_noise(signal, 1, EbN0)
        y = signal + noise
        received_msg = y > 0
        Pb_pr = np.count_nonzero(msg != received_msg) / len(msg)
        SER.append(Pb_pr)

    return SER


def generate_QPSK_SER_vs_EbN0_Pr(EbN0dB_range):
    """Generate practical SER for a QPSK signal

    The randomly generated message is first converted to its corresponding
    symbol array. Since this is QPSK, the symbol rate is 2. The signal array
    is generated by appending to it the corresponding complex number i.e.
    e^(j*theta) and the theta is different for each of the symbol pattern.
    Noise is added to the signal and then the receiver decodes the signal by
    checking the sign of both the real and imaginary part to obtain the received
    message array.

    Args:
        EbN0dB_range (range): range object containing the range of SNR
                              values used in simulations

    Returns:
        SER (list): list of SER values as computed during the simulations
    """
    msg = np.random.randint(low=0, high=2, size=int(1e6))
    symbols = np.array([msg[0::2], msg[1::2]])
    signal = []
    for k in range(np.size(symbols, axis=1)):
        b_0 = symbols[0, k]
        b_1 = symbols[1, k]
        if b_0 == 0 and b_1 == 0:
            theta = 5.0 * np.math.pi / 4.0
            signal.append(np.array(np.cos(theta) + 1j * np.sin(theta)))
        elif b_0 == 0 and b_1 == 1:
            theta = 3.0 * np.math.pi / 4.0
            signal.append(np.array(np.cos(theta) + 1j * np.sin(theta)))
        elif b_0 == 1 and b_1 == 1:
            theta = 1.0 * np.math.pi / 4.0
            signal.append(np.array(np.cos(theta) + 1j * np.sin(theta)))
        elif b_0 == 1 and b_1 == 0:
            theta = 7.0 * np.math.pi / 4.0
            signal.append(np.array(np.cos(theta) + 1j * np.sin(theta)))

    SER = []
    for EbN0dB in EbN0dB_range:
        EbN0 = 10 ** (EbN0dB / 10.0)
        noise = generate_noise(signal, 2, EbN0)
        y = signal + noise
        received_msg = []
        for i in y:
            received_msg.append(np.real(i) > 0)
            received_msg.append(np.imag(i) > 0)
        Pb_pr = np.count_nonzero(msg != received_msg) / len(msg)
        SER.append(2 * Pb_pr)

    return SER


if __name__ == "__main__":
    EbN0dB_range = range(1, 11)
    SER_Pr_BPSK = generate_BPSK_SER_vs_EbN0_Pr(EbN0dB_range)
    SER_Pr_QPSK = generate_QPSK_SER_vs_EbN0_Pr(EbN0dB_range)
    plt.plot(EbN0dB_range, SER_Pr_BPSK, "s-", label="BPSK Practical SER")
    plt.plot(EbN0dB_range, SER_Pr_QPSK, "D-", label="QPSK Practical SER")
    plt.xlabel("SNR (dB)")
    plt.xscale("linear")
    plt.ylabel("SER")
    plt.yscale("log")
    plt.legend()
    plt.grid()
    plt.show()
